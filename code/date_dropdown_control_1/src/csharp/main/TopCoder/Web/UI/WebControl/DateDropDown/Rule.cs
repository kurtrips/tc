// Rule.cs
// Copyright (c) 2007, TopCoder, Inc. All rights reserved.
using System;
using System.ComponentModel;
using System.Collections.Generic;
using System.Web.UI;
using System.Globalization;

namespace TopCoder.Web.UI.WebControl.DateDropDown
{
    /// <summary>
    /// <para>The class representing a custom Rule property for the web-control. The abstraction of a rule for date
    /// generation pattern is implemented by this class. It contains several properties (DateType, DateValue, TimeValue,
    /// YearDivisor,   ReverseOrder, and Interleave), which serves as sub-propertis of this custom property class. So,
    /// the DatePattern custom property class contains just several simple sub-properties. A special method
    /// (generateDates(...)) will produce an array of  generated date items for the rule, which can be directly reused
    /// by any list-based web-control. </para>
    /// </summary>
    /// <threadsafety>
    /// <para>This class is not thread-safe. It is mutable and will be used by
    /// web-controls, which do not execute additional threads. </para>
    /// </threadsafety>
    /// <author>MiG-29</author>
    /// <author>TCSDEVELOPER</author>
    /// <version>1.0</version>
    /// <copyright>Copyright (c) 2007, TopCoder, Inc. All rights reserved.</copyright>
    [TypeConverter(typeof(ExpandableObjectConverter))]
    [ParseChildren(true)]
    public class Rule
    {
        /// <summary>
        /// Represents the allowed values of the dateType field.
        /// </summary>
        private static readonly string[] AllowableDateTypes = new string[]
            { "Day", "DayMonth", "DayOfMonth", "DayOfWeek" };

        /// <summary>
        /// <para>Represents the "Day" type of date/time items to be generated by this rule. It will be used for parsing
        /// DateType property. This field is directly initialized and never changes later. It can not be null or empty
        /// string.  </para>
        /// </summary>
        private const string DateType_Day = "Day";

        /// <summary>
        /// <para>Represents the "DayMonth" type of date/time items to be generated by this rule. It will be used for
        /// parsing DateType property. This field is directly initialized and never changes later. It can not be
        /// null or empty string.  </para>
        /// </summary>
        private const string DateType_DayMonth = "DayMonth";

        /// <summary>
        /// <para>Represents the "DayOfMonth" type of date/time items to be generated by this rule. It will be used for
        /// parsing DateType property. This field is directly initialized and never changes later. It can not be
        /// null or empty string.  </para>
        /// </summary>
        private const string DateType_DayOfMonth = "DayOfMonth";

        /// <summary>
        /// <para>Represents the "DayOfWeek" type of date/time items to be generated by this rule. It will be used for
        /// parsing DateType property. This field is directly initialized and never changes later. It can not be
        /// null or empty string.  </para>
        /// </summary>
        private const string DateType_DayOfWeek = "DayOfWeek";

        /// <summary>
        /// <para>Represents the type of date/time items to be generated by this rule.
        /// This field is directly initialized. Use the related property to  mutate.
        /// It can not be null. Initial value is empty string but cannot be set to empty string. </para>
        /// </summary>
        private string dateType = String.Empty;

        /// <summary>
        /// <para>Represents the date value to be used for date/time generating by this rule. This field is directly
        /// initialized. Use the related  property to mutate. It can not be null, but can be empty string. </para>
        /// </summary>
        private string dateValue = String.Empty;

        /// <summary>
        /// <para>Represents the time value to be used for date/time generating by this rule. This field is directly
        /// initialized. Use the related  property to mutate. It can not be null, but can be empty string. </para>
        /// </summary>
        private string timeValue = String.Empty;

        /// <summary>
        /// <para>Represents the divisor for years to be divided with a 0 remainder. It is used as a part of generating
        /// rule. This field allows to add only dates, which relate to the years divideable by this field value without
        /// remainder. For example, use 4 for leap years. This field is directly initialized. Use the related
        /// property to mutate. It should be a positive number greater than 0. </para>
        /// </summary>
        private int yearDivisor = 1;

        /// <summary>
        /// <para>Represents the reverse order for date/time generating by this rule. For example, for "DayOfMonth" rule,
        /// the DateValue=1 with the ReverseOrder=false means the first day of the month. But if we change the
        /// ReverseOrder to true for the  same rule, then the last day of the month will be generated. This field is
        /// directly initialized. Use the related property  to mutate. It can be any boolean value. false - means using
        /// of the standard order, true - means using of reversed order. </para>
        /// </summary>
        private bool reverseOrder = false;

        /// <summary>
        /// <para>Represents the interleave value to be used for date/time generating by this rule. It can be used with
        /// different date/time generation rules. For example, it allows to get values from interleaved weeks for
        /// DayOfWeek rule, and so on. This field is directly initialized. Use the related property to mutate. It
        /// should be a positive number (including 0). </para>
        /// </summary>
        private int interleave = 0;

        /// <summary>
        /// <para>Represents the getter/setter property for the DateType of the rule. This can be
        /// Day, DayMonth, DayOfMonth or DayOfWeek.</para>
        /// </summary>
        /// <value> This can be Day, DayMonth, DayOfMonth or DayOfWeek. </value>
        /// <exception cref="ArgumentNullException">if value is null</exception>
        /// <exception cref="ArgumentException">if value is not one of the values mentioned above.</exception>
        [Category("Behavior")]
        [NotifyParentProperty(true)]
        public virtual string DateType
        {
            get
            {
                return dateType;
            }
            set
            {
                Helper.ValidateNotNull(value, "DateType");
                ValidateDateType(value);
                dateType = value;
            }
        }

        /// <summary>
        /// <para>Represents the getter/setter property for the Date value of the rule.</para>
        /// For the DayMonth type, this value must be always in [dd-MM] form regardless of the input format.
        /// </summary>
        /// <exception cref="ArgumentNullException">if value is null</exception>
        /// <value>Date value of the rule.
        /// For the DayMonth type, this value must be always in [dd-MM] form regardless of the input format.
        /// </value>
        [Category("Behavior")]
        [NotifyParentProperty(true)]
        public virtual string DateValue
        {
            get
            {
                return dateValue;
            }
            set
            {
                Helper.ValidateNotNull(value, "DateValue");
                dateValue = value.Trim();
            }
        }

        /// <summary>
        /// <para>Represents the getter/setter property for the time Value of the rule.
        /// The value must always be in the format [HH:mm tt] regardless of the input format.
        /// </para>
        /// </summary>
        /// <exception cref="ArgumentNullException">if value is null</exception>
        /// <value>time value of the rule.
        /// The value must always be in the format [HH:mm tt] regardless of the input format.
        /// </value>
        [Category("Behavior")]
        [NotifyParentProperty(true)]
        public virtual string TimeValue
        {
            get
            {
                return timeValue;
            }
            set
            {
                Helper.ValidateNotNull(value, "TimeValue");
                timeValue = value.Trim();
            }
        }

        /// <summary>
        /// <para>Represents the getter/setter property for the yearDivisor value of the rule.</para>
        /// </summary>
        /// <exception cref="ArgumentException">if value to be set is 0 or negative.</exception>
        /// <value>time value of the rule. Default value is 1.</value>
        [Category("Behavior")]
        [NotifyParentProperty(true)]
        public virtual int YearDivisor
        {
            get
            {
                return yearDivisor;
            }
            set
            {
                Helper.ValidatePositive(value, "YearDivisor", false);
                yearDivisor = value;
            }
        }

        /// <summary>
        /// <para>Represents the getter/setter property for the reverseOrder value of the rule.</para>
        /// </summary>
        /// <value>reverseOrder value of the rule. Default value is false.</value>
        [Category("Behavior")]
        [NotifyParentProperty(true)]
        public virtual bool ReverseOrder
        {
            get
            {
                return reverseOrder;
            }
            set
            {
                reverseOrder = value;
            }
        }

        /// <summary>
        /// <para>Represents the getter/setter property for the interleave value of the rule.</para>
        /// </summary>
        /// <exception cref="ArgumentException">if value to be set is 0 or negative.</exception>
        /// <value>interleave value of the rule. Default value is 0.</value>
        [Category("Behavior")]
        [NotifyParentProperty(true)]
        public virtual int Interleave
        {
            get
            {
                return interleave;
            }
            set
            {
                Helper.ValidatePositive(value, "Interleave", true);
                interleave = value;
            }
        }

        /// <summary>
        /// <para>The default constructor. Does nothing.</para>
        /// </summary>
        public Rule()
        {
        }

        /// <summary>
        /// <para>Generates and returns the date/time items as defined by this rule.</para>
        /// </summary>
        /// <param name="inputDateFormat">
        /// Represents the date/time formatting string for all the user provided date and times for the date/time
        /// generation rules. The standard .NET date/time formatting string format is used for this argument value. Can
        /// not be null or empty string.
        /// </param>
        /// <param name="displayDateFormat">
        /// Represents the date/time formatting string for the output date/time items generated in this class. The
        /// standard .NET date/time formatting string format is used for this argument value. Can not be null or empty
        /// string.
        /// </param>
        /// <param name="startDate">
        /// Represents the starting date/time value for generating date/time items in this class. The format of this
        /// argument value is determined by the inputDateFormat argument. Can not be null or empty string.
        /// </param>
        /// <param name="stopDate">
        /// Represents the ending date/time value for generating date/time items in this class. The format of this
        /// argument value is determined by the inputDateFormat argument. Can not be null or empty string.
        /// </param>
        /// <returns>
        /// an array of generated date/time items by this rule. It can not be null, but can be empty. No array element
        /// can be null or empty string.
        /// </returns>
        /// <exception cref="ArgumentNullException">If any argument is null</exception>
        /// <exception cref="ArgumentException">If any argument is empty</exception>
        /// <exception cref="RuleInvalidDataException">
        /// if any problem with generating date/time items by Rule class will occur (like
        /// absent properties for Rule, wrong values in those properties, and so on).
        /// </exception>
        public string[] GenerateDates(string inputDateFormat, string displayDateFormat,
            string startDate, string stopDate)
        {
            //Validation
            Helper.ValidateNotNullNotEmpty(inputDateFormat, "inputDateFormat");
            Helper.ValidateNotNullNotEmpty(displayDateFormat, "displayDateFormat");
            Helper.ValidateNotNullNotEmpty(startDate, "startDate");
            Helper.ValidateNotNullNotEmpty(stopDate, "stopDate");

            //Parse to dates
            DateTime start, end;
            try
            {
                start = DateTime.ParseExact(startDate, inputDateFormat, CultureInfo.InvariantCulture);
                end = DateTime.ParseExact(stopDate, inputDateFormat, CultureInfo.InvariantCulture);
            }
            catch (Exception e)
            {
                throw new RuleInvalidDataException("Could not convert date string to DateTime object.", e);
            }

            //Check startDate is smaller than endDate
            if (start > end)
            {
                throw new RuleInvalidDataException("Start date must not be greater than end date.");
            }

            //Parse dates according to date type
            switch (DateType)
            {
                case DateType_Day:
                {
                    return GenerateDatesForDayDateType(inputDateFormat, displayDateFormat, start, end);
                }
                case DateType_DayMonth:
                {
                    return GenerateDatesForDayMonthDateType(inputDateFormat, displayDateFormat, start, end);
                }
                case DateType_DayOfMonth:
                {
                    return GenerateDatesForDayOfMonthDateType(inputDateFormat, displayDateFormat, start, end);
                }
                case DateType_DayOfWeek:
                {
                    return GenerateDatesForDayOfWeekDateType(inputDateFormat, displayDateFormat, start, end);
                }
            }

            return new string[0];
        }

        /// <summary>
        /// Generates dates in the given format for the Day DateType with the start and end dates.
        /// </summary>
        /// <param name="inputFormat">The inputDate format</param>
        /// <param name="displayFormat">The display date format</param>
        /// <param name="start">The start date from which to start searching</param>
        /// <param name="end">The end date at which to stop searching</param>
        /// <returns>An array of date strings after applying the rule from the start date to end date.
        /// The format of strings in this array is the display date format.
        /// </returns>
        ///
        /// <remarks>
        /// Due to a design bug, the date must be specified in such a way that the format [DateValue][space][TimeValue]
        /// is in the correct input date format. Conversely, any input date formats not in [DateValue][space][TimeValue]
        /// format are not supported.
        /// </remarks>
        /// <exception cref="RuleInvalidDataException">If the dates could not be generated due to either incorrect
        /// inputFormat/displayFormat or invalid DateValue/TimeValue</exception>
        private string[] GenerateDatesForDayDateType(string inputFormat, string displayFormat,
            DateTime start, DateTime end)
        {
            string dateAndTime = String.Empty;
            DateTime parsedDate;
            List<DateTime> ret = new List<DateTime>();

            try
            {
                //Time values may be semi colon delimited
                string[] timeValues = TimeValue.Split(';');
                foreach (string timeValue in timeValues)
                {
                    //Form a [DateValue][space][TimeValue] string
                    dateAndTime = DateValue.TrimEnd() + " " + timeValue.TrimStart();
                    dateAndTime = dateAndTime.Trim();

                    //Try to parse it using inputFormat
                    parsedDate = DateTime.ParseExact(dateAndTime, inputFormat, CultureInfo.InvariantCulture);

                    if (parsedDate.Year % YearDivisor == 0 && parsedDate >= start && parsedDate <= end)
                    {
                        ret.Add(parsedDate);
                    }
                }
            }
            catch (Exception e)
            {
                throw new RuleInvalidDataException(dateAndTime + " is not a valid date for the format : "
                    + inputFormat, e);
            }

            return FormatListAndReturnArray(ret, displayFormat);
        }

        /// <summary>
        /// Generates dates in the given format for the DayMonth DateType with the start and end dates.
        /// </summary>
        /// <param name="inputFormat">The inputDate format</param>
        /// <param name="displayFormat">The display date format</param>
        /// <param name="start">The start date from which to start searching</param>
        /// <param name="end">The end date at which to stop searching</param>
        /// <returns>An array of date strings after applying the rule from the start date to end date.
        /// The format of strings in this array is the display date format.
        /// </returns>
        /// <exception cref="RuleInvalidDataException">If the dates could not be generated due to either incorrect
        /// inputFormat/displayFormat or invalid DateValue/TimeValue</exception>
        private string[] GenerateDatesForDayMonthDateType(string inputFormat, string displayFormat,
            DateTime start, DateTime end)
        {
            //Parse day and month
            int day, month;
            try
            {
                string[] dayAndMonth = DateValue.Split('-');
                month = int.Parse(dayAndMonth[0]);
                day = int.Parse(dayAndMonth[1]);
            }
            catch (Exception e)
            {
                throw new RuleInvalidDataException(DateValue + " must be in the format [month]-[day].", e);
            }

            //Get the time parts
            IList<KeyValuePair<int, int>> hourMinPairs = ParseTimeValue();

            //Return the dates
            IList<DateTime> retList = new List<DateTime>();
            for (int year = start.Year; year <= end.Year; year++)
            {
                if (year % YearDivisor == 0)
                {
                    //One date each to be returned for each time value specified in TimeValue
                    foreach (KeyValuePair<int, int> hourMinPair in hourMinPairs)
                    {
                        if (DateTime.DaysInMonth(year, month) >= day)
                        {
                            //Create the date
                            DateTime dateFormed = new DateTime(year, month, day, hourMinPair.Key, hourMinPair.Value, 0);

                            //Add if inclusive of ranges
                            if (dateFormed >= start && dateFormed <= end)
                            {
                                retList.Add(dateFormed);
                            }
                        }
                    }
                }
            }

            return FormatListAndReturnArray(retList, displayFormat);
        }

        /// <summary>
        /// Generates dates in the given format for the DayOfMonth DateType with the start and end dates.
        /// </summary>
        /// <param name="inputFormat">The inputDate format</param>
        /// <param name="displayFormat">The display date format</param>
        /// <param name="start">The start date from which to start searching</param>
        /// <param name="end">The end date at which to stop searching</param>
        /// <returns>An array of date strings after applying the rule from the start date to end date.
        /// The format of strings in this array is the display date format.
        /// </returns>
        /// <exception cref="RuleInvalidDataException">If the dates could not be generated due to either incorrect
        /// inputFormat/displayFormat or invalid DateValue/TimeValue</exception>
        private string[] GenerateDatesForDayOfMonthDateType(string inputFormat, string displayFormat,
            DateTime start, DateTime end)
        {
            List<DateTime> retList = new List<DateTime>();

            //Get the list of days to be considered
            IList<int> dayNumbers = GetDayNumbersForDaysOfMonth();

            //Get the time parts
            IList<KeyValuePair<int, int>> hourMinPairs = ParseTimeValue();

            //Is set to true when we go past the end date while searching
            bool mustBreak = false;
            int monthNow = start.Month, yearNow = start.Year;

            //Keep iterating while we do not cross the month and year of the end date
            while ((end.Year * 12 + end.Month >= yearNow * 12 + monthNow) && !mustBreak)
            {
                //Iterate through all the day numbers
                for (int dayIndex = 0; dayIndex < dayNumbers.Count && !mustBreak; dayIndex++)
                {
                    //Get the current day and reverse if ReverseOrder is true
                    int dayNow = dayNumbers[dayIndex];
                    if (ReverseOrder)
                    {
                        dayNow = DateTime.DaysInMonth(yearNow, monthNow) - dayNow + 1;
                    }

                    //Day number must be valid for the given month and year and also year must be divisible by YearDivisor
                    if (dayNow > 0 && dayNow <= DateTime.DaysInMonth(yearNow, monthNow) && yearNow % YearDivisor == 0)
                    {
                        //Each time part must be created for each given day
                        for (int timeIndex = 0; timeIndex < hourMinPairs.Count; timeIndex++)
                        {
                            //Form a date
                            DateTime dateNow = new DateTime(yearNow, monthNow, dayNow,
                                hourMinPairs[timeIndex].Key, hourMinPairs[timeIndex].Value, 0);

                            //Add if inclusive of ranges
                            if (dateNow >= start && dateNow <= end)
                            {
                                retList.Add(dateNow);
                            }

                            //Break if greater than end date
                            if (dateNow > end && !reverseOrder)
                            {
                                mustBreak = true;
                                break;
                            }
                        }
                    }
                }

                //Increase monthNow by 1 and round month and year if necessary
                if (!mustBreak)
                {
                    monthNow = (monthNow % 12) + 1;
                    if (monthNow == 1)
                    {
                        yearNow++;
                    }
                }
            }

            return FormatListAndReturnArray(retList, displayFormat);
        }

        /// <summary>
        /// Generates dates in the given format for the DayOfWeek DateType with the start and end dates.
        /// </summary>
        /// <param name="inputFormat">The inputDate format</param>
        /// <param name="displayFormat">The display date format</param>
        /// <param name="start">The start date from which to start searching</param>
        /// <param name="end">The end date at which to stop searching</param>
        /// <returns>An array of date strings after applying the rule from the start date to end date.
        /// The format of strings in this array is the display date format.
        /// </returns>
        /// <exception cref="RuleInvalidDataException">If the dates could not be generated due to either incorrect
        /// inputFormat/displayFormat or invalid DateValue/TimeValue</exception>
        private string[] GenerateDatesForDayOfWeekDateType(string inputFormat, string displayFormat,
            DateTime start, DateTime end)
        {
            List<DateTime> retList = new List<DateTime>();

            //Get the days of the week to be considered
            IList<DayOfWeek> daysOfWeek = GetWeekDaysForDayOfWeek();

            //Get the time parts
            IList<KeyValuePair<int, int>> hourMinPairs = ParseTimeValue();

            //Get the week numbers
            IDictionary<DateTime, int> weekNumbers = GetWeekNumbers(start, end);

            //Iterate all dates between start and endDate
            for (DateTime date = start; date <= end; date = date.AddDays(1))
            {
                //Get only interleaving week numbers
                if (weekNumbers[date] % (Interleave + 1) == 0)
                {
                    //Only dates with years divisible by YearDivisor are allowed
                    if (date.Year % YearDivisor == 0)
                    {
                        for (int j = 0; j < hourMinPairs.Count; j++)
                        {
                            DateTime dateAndTime = new DateTime(date.Year, date.Month, date.Day,
                                hourMinPairs[j].Key, hourMinPairs[j].Value, 0);

                            //Add if date has the correct day of week
                            if (daysOfWeek.Contains(dateAndTime.DayOfWeek))
                            {
                                if (dateAndTime >= start && dateAndTime <= end)
                                {
                                    retList.Add(dateAndTime);
                                }
                            }
                            //No need to try out more times for the day when the
                            //day itself is not the correct day of week
                            else
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        //Move ahead by a year minus one day.
                        date = date.AddYears(1).AddDays(1);
                    }
                }
            }

            return FormatListAndReturnArray(retList, displayFormat);
        }

        /// <summary>
        /// Parses the TimeValue part to a list of hour and minute pairs.
        /// The TimeValue can be of the form [HH:mm tt;HH:mm tt;.......;HH:mm tt]
        /// </summary>
        /// <returns>a list of hour and minute pairs.</returns>
        /// <exception cref="RuleInvalidDataException">
        /// If the TimeValue format is invalid or
        /// if the parsed hours and minutes are invalid (greater than 23 or 59 respectively)
        /// </exception>
        private IList<KeyValuePair<int, int>> ParseTimeValue()
        {
            IList<KeyValuePair<int, int>> hourMinPairs = new List<KeyValuePair<int, int>>();
            if (TimeValue.Equals(String.Empty))
            {
                //return a single time with hour and min set to zero
                hourMinPairs.Add(new KeyValuePair<int, int>(0,0));
                return hourMinPairs;
            }

            //Parse out the times specified (delimited by ;)
            string[] timeValues = TimeValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
            for (int i = 0; i < timeValues.Length; i++)
            {
                int hour = 0, min = 0;
                try
                {
                    //Here we get the "6:00" part of "6:00 PM" and extract the hour and min parts
                    string onlyTimePart = timeValues[i].Split(' ')[0];
                    hour += int.Parse(onlyTimePart.Split(':')[0]);
                    min += int.Parse(onlyTimePart.Split(':')[1]);

                    //12:35 AM is actually 00:35
                    //12:35 PM is not 24:35
                    if (timeValues[i].Contains("PM") && hour < 12)
                    {
                        hour += 12;
                    }
                    if (timeValues[i].Contains("AM") && hour == 12)
                    {
                        hour -= 12;
                    }
                }
                catch (Exception e)
                {
                    throw new RuleInvalidDataException(
                        timeValues[i] + " must be in format: '[hour]:[minute] [AM/PM]'.", e);
                }

                if (hour > 23 || min > 59)
                {
                    throw new RuleInvalidDataException(timeValues[i] + " is an invalid time.");
                }

                //Add each time parsed to the list.
                hourMinPairs.Add(new KeyValuePair<int, int>(hour, min));
            }

            return hourMinPairs;
        }

        /// <summary>
        /// Parses enumerated day numbers for a month returns a list containing those day numbers.
        /// </summary>
        /// <returns>
        /// a list containing those day numbers.
        /// </returns>
        /// <exception cref="RuleInvalidDataException">
        /// If the DateValue is not in valid format.
        /// </exception>
        private IList<int> GetDayNumbersForDaysOfMonth()
        {
            List<int> ret = new List<int>();
            if (DateValue.Equals(String.Empty))
            {
                return ret;
            }

            try
            {
                //A value like "1-5;7;9-12;15" can be parsed here.
                //First split using ';'
                string[] firstSplit = DateValue.Split(';');
                for (int i = 0; i < firstSplit.Length; i++)
                {
                    //Now split using '-'
                    string[] secondSplit = firstSplit[i].Split('-');

                    //We have a day range
                    if (secondSplit.Length == 2)
                    {
                        int rangeStart = int.Parse(secondSplit[0]);
                        int rangeEnd = int.Parse(secondSplit[1]);
                        for (int j = rangeStart; j <= rangeEnd; j++)
                        {
                            ret.Add(j);
                        }
                    }
                    //We have a normal single date
                    else
                    {
                        ret.Add(int.Parse(secondSplit[0]));
                    }
                }
            }
            catch (Exception e)
            {
                throw new RuleInvalidDataException(DateValue + " is an invalid date value.", e);
            }

            //Sort the day numbers before returning
            ret.Sort();

            return ret;
        }

        /// <summary>
        /// Parses enumerated days of week for a week and returns a list containing those DayOfWeeks.
        /// </summary>
        /// <returns>
        /// a list containing those DayOfWeeks.
        /// </returns>
        /// <exception cref="RuleInvalidDataException">
        /// If the DateValue is not in valid format.
        /// </exception>
        private IList<DayOfWeek> GetWeekDaysForDayOfWeek()
        {
            IList<DayOfWeek> ret = new List<DayOfWeek>();
            if (DateValue.Equals(String.Empty))
            {
                return ret;
            }

            try
            {
                //A value like "Monday-Wednesday;Friday;Sunday" can be parsed here.
                //First split using ';'
                string[] firstSplit = DateValue.Split(';');
                for (int i = 0; i < firstSplit.Length; i++)
                {
                    //Now split using '-'
                    string[] secondSplit = firstSplit[i].Split('-');

                    //The parsed value must be a defined enum value
                    if (!Enum.IsDefined(typeof(DayOfWeek), secondSplit[0]))
                    {
                        throw new RuleInvalidDataException(secondSplit[0] + " is an invalid DayOfWeek value.");
                    }

                    //We have a DayOfWeek range
                    if (secondSplit.Length == 2)
                    {
                        //The parsed value must be a defined enum value
                        if (!Enum.IsDefined(typeof(DayOfWeek), secondSplit[1]))
                        {
                            throw new RuleInvalidDataException(secondSplit[1] + " is an invalid DayOfWeek value.");
                        }

                        DayOfWeek rangeStart = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), secondSplit[0]);
                        DayOfWeek rangeEnd = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), secondSplit[1]);
                        for (DayOfWeek j = rangeStart; j <= rangeEnd; j++)
                        {
                            ret.Add(j);
                        }
                    }
                    //We have a normal single date
                    else
                    {
                        ret.Add((DayOfWeek)Enum.Parse(typeof(DayOfWeek), secondSplit[0]));
                    }
                }
            }
            catch (RuleInvalidDataException e)
            {
                throw e;
            }
            catch (Exception e)
            {
                throw new RuleInvalidDataException(DateValue + " is an invalid date value.", e);
            }

            return ret;
        }

        /// <summary>
        /// Gets the week numbers of all dates starting from start to end. The first date is given week 0
        /// and the week number increases on each Sunday.
        /// </summary>
        /// <param name="start">The start date</param>
        /// <param name="end">The end date</param>
        /// <returns>A dictionary containing the week numbers (Value) of all dates (Key) starting from start to end.
        /// </returns>
        private static IDictionary<DateTime, int> GetWeekNumbers(DateTime start, DateTime end)
        {
            IDictionary<DateTime, int> ret = new Dictionary<DateTime, int>();

            //ASsign a week number to each date
            int weekNumber = 0;
            for (DateTime date = start; date <= end; date = date.AddDays(1))
            {
                ret[date] = weekNumber;
                if (date.DayOfWeek == DayOfWeek.Saturday)
                {
                    weekNumber++;
                }
            }

            return ret;
        }

        /// <summary>
        /// Ensures that the DateType is one of "Day", "DayMonth", "DayOfMonth", DayOfWeek".
        /// </summary>
        /// <param name="dateType">The dateType to validate</param>
        /// <exception cref="ArgumentException">if the above condition is not met</exception>
        private static void ValidateDateType(string dateType)
        {
            if (Array.IndexOf(AllowableDateTypes, dateType) < 0)
            {
                //Unknown dateType value
                throw new ArgumentException(dateType + " is not a valid value for DateType.", "DateType");
            }
        }

        /// <summary>
        /// Formats a list of dates to strings using displayDateFormat and returns the array formed
        /// </summary>
        /// <param name="retList">a list of dates</param>
        /// <param name="displayFormat">the diaplay format</param>
        /// <returns>An array of string representations of dates.</returns>
        private static string[] FormatListAndReturnArray(IList<DateTime> retList, string displayFormat)
        {
             //Form array to return
            string[] ret = new string[retList.Count];
            for (int i = 0; i < retList.Count; i++)
            {
                ret[i] = retList[i].ToString(displayFormat, CultureInfo.InvariantCulture);
            }
            return ret;
        }
    }
}
